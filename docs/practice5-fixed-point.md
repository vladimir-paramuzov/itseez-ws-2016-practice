# Практика 5: Переход на целочисленную арифметику

[![Feedback](feedback.png)][feedback_day5]

## Цели

__Цель данной работы__ — освоить такую технику, как ускорение вычислений за счет
перехода на типы данных, которые более "дружественны" для аппаратной платформы.
Типичными примерами являются переходы от вычислений с двойной точностью (тип
`double`) к вычислениям с одинарной точностью (`float`) или от вычислений с
плавающей точкой к целочисленным. В нашем случае будет опробован второй вариант,
то есть переход c "floating-point" на ["fixed-point"][fixed-point].

При этом нужно понимать, что переход на другие типы данных часто влечет за собой
снижение точности вычислений. Поэтому нужно следить за этим, и четко понимать,
какую максимальную погрешность мы можем внести, и насколько это приемлемо для
алгоритма в целом.

## Задачи

  1. Создать "fixed-point" реализацию функции `ConvertColor_BGR2GRAY_BT709`.
  1. Оценить полученные ускорения и точность вычислений.

## Инструкция по выполнению работы

Поскольку это очередной шаг в оптимизации, его необходимо будет выполнить по уже
знакомому нам алгоритму: собираем данные о производительности базовой версии,
осуществляем оптимизацию, анализируем полученное ускорение.

  1. Перед началом оптимизации необходимо осуществить знакомые нам
     предварительные действия:

     - Получить актуальную версию кодов из центрального репозитория (см.
       [инструкции][git-update]). Затем нужно собрать проект и проверить его
       работоспособность, запустив тесты и демо-приложение.

     - Далее нужно создать новую ветку в Git для выполнения практического
       задания. Изменения необходимо постоянно фиксировать в истории Git,
       выкладывая в рабочую ветку на GitHub и контролируя успешность
       тестирования на Travis-CI.

     - Запустить тесты производительности функции `ConvertColor_BGR2GRAY_BT709`
       и сохранить XML-файл с результатами. Этот файл в дальнейшем будет
       использован для сравнения производительности до и после оптимизации.

  1. Разобраться с алгоритмом `ConvertColor_BGR2GRAY_BT709` и оптимизировать
     его, перейдя от вычислений с плавающей запятой к целочисленным операциям.
     Для этого используйте заготовку `ConvertColor_BGR2GRAY_BT709_fpt`.

     - Идея состоит в том, чтобы представить вещественные коэффициенты в виде
       целых чисел (см. [Q number format][qmn]). Вам необходимо выбрать тип
       данных, которого было бы достаточно для представления коэффициентов.
       Варианты: `unsigned char`, `unsigned short`, `unsigned int`.

     - Кроме этого, вы должны понять, в каком типе данных нужно вести
       вычисления, поскольку коэффициенты предстоит умножать на значения
       интенсивности, и осуществлять другие операции.

     - Затем, когда вы определитесь с типом данных, останется собственно
       реализовать перевод коэффициентов в целочисленный формат, произведение
       вычислений, и обратный возврат к `unsigned char`, который должен быть на
       выходе.

     - Финальным шагом стоит постараться упростить и почистить код.

  1. В конце, как обычно, стоит убедиться, что оптимизированная функция работает
     быстрее, чем оригинальный код. Проанализируйте ускорения, сравнивая отчеты
     о производительности до и после оптимизации.

Поскольку данное задание может потребовать меньше времени, чем предыдущие, вы
можете вернуться либо к прошлым заданиям, либо начать готовиться к следующему
шагу, то есть начать размышлять над тем, как можно векторизовать данный код.

<!-- LINKS -->

[feedback_day5]: https://docs.google.com/forms/d/1F8nL_jIJQsE4StaTukjlIJ-W93Zfvxyukh0YmltRDzQ/viewform
[fixed-point]:   https://en.wikipedia.org/wiki/Fixed-point_arithmetic
[git-update]:    https://github.com/itseez-academy/itseez-ws-2016-practice/blob/master/docs/practice2-profiling-and-benchmarking.md#Получение-актуальной-версии-исходных-файлов
[qmn]:           https://en.wikipedia.org/wiki/Q_%28number_format%29
