# Практика 6: Использование векторных инструкций

[![Feedback](feedback.png)][feedback_day6]

## Цели

__Цель данной работы__ — освоить технику векторизации вычислений путём
переписывания кода с использованием инструкций из расширенного набора команд
SSE2/SSSE3, реализующими `SIMD` идиому.

## Задачи

  1. Создать векторную реализацию функции `ConvertColor_BGR2GRAY_BT709_fpt`
     (имеется в виду именно fixed-point версия).
  1. Оценить полученные ускорения.

## Общая последовательность действий

Поскольку это очередной шаг в оптимизации, его необходимо будет выполнить по
уже знакомому алгоритму: собираем данные о производительности базовой версии,
осуществляем оптимизацию, анализируем полученное ускорение.

  1. Перед началом оптимизации необходимо осуществить обычные предварительные
     действия:

     - Получить актуальную версию кодов из центрального репозитория (см.
       [инструкции][git-update]). Затем нужно собрать проект и проверить его
       работоспособность, запустив тесты и демо-приложение.

     - Далее нужно создать новую ветку в Git для выполнения практического
       задания. Изменения необходимо постоянно фиксировать в истории Git,
       выкладывая в рабочую ветку на GitHub и контролируя успешность
       тестирования на Travis-CI.

     - Запустить тесты производительности функции `ConvertColor_BGR2GRAY_BT709`
       и сохранить XML-файл с результатами. Этот файл в дальнейшем будет
       использован для сравнения производительности до и после оптимизации.

  1. Ознакомиться с реализацией `ConvertColor_BGR2GRAY_BT709_fpt`, предлагаемой
     в качестве исходной. В качестве предварительного шага вы можете сравнить
     производительность исходной версии `ConvertColor_BGR2GRAY_BT709`,
     предложенной `ConvertColor_BGR2GRAY_BT709_fpt` и версии, разработанной вами
     вчера.

  1. Затем необходимо оптимизировать предложенную версию
     `ConvertColor_BGR2GRAY_BT709_fpt`, используя инструкции из наборов комманд
     SSE2/SSSE3. Для этого используйте заготовку
     `ConvertColor_BGR2GRAY_BT709_simd`. (Вообще вы можете попытаться
     оптимизировать и свою собственную fixed-point реализацию, но тогда вам
     могут пригодиться иные векторные команды.)

  1. В конце, как обычно, стоит убедиться, что оптимизированная функция работает
     быстрее, чем оригинальный код. Проанализируйте ускорения, сравнивая отчеты
     о производительности до и после оптимизации.

## Подсказки для выполнения работы

  1. В конце функции `ConvertColor_BGR2GRAY_BT709_simd` стоит вызов функции
     `ConvertColor_BGR2GRAY_BT709_fpt`. Это сделано лишь для того, чтобы в
     стартовом состоянии проходили тесты. Сразу после сбора первичных метрик
     производительности стоит этот вызов убрать.

  1. Следующий набор SSE операций (интринсиков) достаточен для выполнения
     данного задания (см. [подробное описание интринсиков][intrin_guide]):

     - `_mm_set_epi8`
     - `_mm_set1_epi16`
     - `_mm_setzero_si128`
     - `_mm_loadu_si128`
     - `_mm_or_si128`
     - `_mm_shuffle_epi8`
     - `_mm_unpacklo_epi8`
     - `_mm_unpackhi_epi8`
     - `_mm_add_epi16`
     - `_mm_mullo_epi16`
     - `_mm_srli_epi16`
     - `_mm_packus_epi16`
     - `_mm_storeu_si128`

  1. Например, `_mm_set1_epi16` позволяет одной инструкцией установить восемь
     16-битных элементов вектора в одно значение, а `_mm_setzero_si128` — это
     эффективный способ обнуления вектора:

     ```cpp
     __m128i green_coeff = _mm_set1_epi16(183);
     __m128i zero = _mm_setzero_si128();
     ```

  1. Для удовлетворения заданных критериев точности достаточно воспользоваться
     числами с фиксированной точкой использующими 8 бит для дробной части:
     `Q7.8`. Другими словами, предлагается использовать 16 битный тип для
     представления коэффициентов.

  1. Индексы для векторной распаковки `BGR` формата изображения, а также пример
     распаковки для `R` канала являются частью заготовки
     `ConvertColor_BGR2GRAY_BT709_simd`.

По завершении реализации векторной версии как обычно стоит проверить
корректность и ускорения, запуская тесты. На Linux ускорение SIMD версии по
отношению к fixed-point достигали порядка 3.5x.

<!-- LINKS -->

[feedback_day6]: https://docs.google.com/forms/d/1iNNPX4Z_2aoWVOfh_ZEUVFuy_AJ4V0n5wZ3p7NWPZO4/viewform
[git-update]:    https://github.com/itseez-academy/itseez-ws-2016-practice/blob/master/docs/practice2-profiling-and-benchmarking.md#Получение-актуальной-версии-исходных-файлов
[intrin_guide]:  https://software.intel.com/sites/landingpage/IntrinsicsGuide/
